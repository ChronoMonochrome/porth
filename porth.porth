// In progress rewrite of ./porth.py in Porth

include "std.porth"

macro PUTD_BUFFER_CAP 32 end
macro MEM_CAPACITY 640000 end
macro SIM_STACK_CAP 1024 end

macro OP_PUSH_INT 0 end
macro OP_PLUS     1 end
macro OP_MINUS    2 end
macro OP_PRINT    3 end
macro OP_DUP      4 end
macro OP_DROP     5 end
macro COUNT_OPS   6 end

macro sizeof(Op)    16 end
macro Op.type       0 + end
macro Op.operand    8 + end
macro @Op.type      Op.type @64 end
macro !Op.type      Op.type !64 end
macro @Op.operand   Op.operand @64 end
macro !Op.operand   Op.operand !64 end

// Memory Layout
macro putd-buffer mem end

macro file_path_cstr putd-buffer PUTD_BUFFER_CAP + end
macro fd file_path_cstr 8 + end
macro statbuf fd 8 + end

macro content statbuf sizeof(stat) + end
macro line content sizeof(Str) + end
macro word line sizeof(Str) + end
macro line_number word sizeof(Str) + end
macro line_start line_number 8 + end
macro streq_a line_start 8 + end
macro streq_b streq_a sizeof(Str) + end

macro sim-stack-count streq_b sizeof(Str) + end
macro sim-stack sim-stack-count 8 + end
macro ops-count sim-stack SIM_STACK_CAP 8 * + end
macro ops ops-count 8 + end

macro sim-stack-push // u64 --
  if sim-stack-count @64 SIM_STACK_CAP >= do
    here eputs ": ERROR: data stack overflow in simulation mode\n" eputs 1 exit
  end
  sim-stack sim-stack-count @64 8 * + !64
  sim-stack-count inc64
end

macro sim-stack-pop // -- u64
  if sim-stack-count @64 0 = do
    here eputs ": ERROR: data stack underflow in simulation mode\n" eputs 1 exit
  end
  sim-stack-count dec64
  sim-stack sim-stack-count @64 8 * + @64
end

macro putd // u64 --
  if dup 0 = do
    "0" puts
  else
    putd-buffer PUTD_BUFFER_CAP +
    while over 0 > do
      1 - dup rot
      10 divmod
      rot swap '0' + . swap
    end

    dup
    putd-buffer PUTD_BUFFER_CAP + swap - swap puts
  end
  drop
end

macro try_to_parse_word_as_int_or_fail_as_unknown_word // n1 s1 - ret
  0 0 while dup word @Str.count < do
    dup word @Str.data + @8

    if dup isdigit lnot do
      file_path_cstr @64 cast(ptr) cstr-to-str eputs
      ":" puts line_number @64 putd
      ":" puts word @Str.data cast(int) line_start @64 - 1 + putd
      ": ERROR: `" eputs word @Str eputs "` is unknown word\n" eputs
      1 exit
    end

    '0' -
    rot 10 * +
    swap
    1 +
  end drop
end

macro streq // n1 s1 n2 s2
  streq_a !Str
  streq_b !Str
  if streq_a @Str.count streq_b @Str.count = do
    0 while
      if dup streq_a @Str.count < do
        dup streq_a @Str.data + @8
        over streq_b @Str.data + @8
        =
      else false end
    do 1 + end
    streq_a @Str.count >=
  else false end
end

macro push-op // type operand -- 
  ops-count @64 sizeof(Op) * ops +
  dup rot swap !Op.operand
  !Op.type
  ops-count inc64
end

macro print-op-type
  if COUNT_OPS 6 != do
    here eputs ": Assertion Failed: Exhaustive handling of Op types in print-op-type\n" eputs
    1 exit
  end

  if dup OP_PUSH_INT = do
    "OP_PUSH_INT" puts
  elif dup OP_PLUS = do
    "OP_PLUS" puts
  elif dup OP_MINUS = do
    "OP_MINUS" puts
  elif dup OP_DUP = do
    "OP_DUP" puts
  elif dup OP_DROP = do
    "OP_DROP" puts
  elif dup OP_PRINT = do
    "OP_PRINT" puts
  else
    here eputs ": Unknown op type\n" eputs 1 exit
  end
  drop
end

macro dump-ops // --
  0 while dup ops-count @64 < do
    // ptr ptr
    dup sizeof(Op) * ops +
    "Type:    " puts dup @Op.type print-op-type "\n" puts
    "Operand: " puts @Op.operand print
    "----------\n" puts
    1 +
  end
  drop
end

// TODO: porth.porth does not run nasm and ld as external commands to finish off the process of compilation
macro compile-ops // --
  "BITS 64\n" puts
  "segment .text\n" puts
  "print:\n" puts
  "    mov     r9, -3689348814741910323\n" puts
  "    sub     rsp, 40\n" puts
  "    mov     BYTE [rsp+31], 10\n" puts
  "    lea     rcx, [rsp+30]\n" puts
  ".L2:\n" puts
  "    mov     rax, rdi\n" puts
  "    lea     r8, [rsp+32]\n" puts
  "    mul     r9\n" puts
  "    mov     rax, rdi\n" puts
  "    sub     r8, rcx\n" puts
  "    shr     rdx, 3\n" puts
  "    lea     rsi, [rdx+rdx*4]\n" puts
  "    add     rsi, rsi\n" puts
  "    sub     rax, rsi\n" puts
  "    add     eax, 48\n" puts
  "    mov     BYTE [rcx], al\n" puts
  "    mov     rax, rdi\n" puts
  "    mov     rdi, rdx\n" puts
  "    mov     rdx, rcx\n" puts
  "    sub     rcx, 1\n" puts
  "    cmp     rax, 9\n" puts
  "    ja      .L2\n" puts
  "    lea     rax, [rsp+32]\n" puts
  "    mov     edi, 1\n" puts
  "    sub     rdx, rax\n" puts
  "    xor     eax, eax\n" puts
  "    lea     rsi, [rsp+32+rdx]\n" puts
  "    mov     rdx, r8\n" puts
  "    mov     rax, 1\n" puts
  "    syscall\n" puts
  "    add     rsp, 40\n" puts
  "    ret\n" puts
  "global _start\n" puts
  "_start:\n" puts
  "    mov [args_ptr], rsp\n" puts

  0 while dup ops-count @64 < do
    dup sizeof(Op) * ops +

    // TODO: compile time assertion
    if COUNT_OPS 6 != do
      here eputs ": Assertion Failed: Exhaustive handling of Op types in compile-ops\n" eputs
      1 exit
    end

    if dup @Op.type OP_PUSH_INT = do
       "    ;; -- push int " puts dup @Op.operand putd " --\n" puts
       "    mov rax, "       puts dup @Op.operand putd "\n" puts
       "    push rax\n"      puts
    elif dup @Op.type OP_PLUS = do
       "    ;; -- plus --\n" puts
       "    pop rax\n" puts
       "    pop rbx\n" puts
       "    add rax, rbx\n" puts
       "    push rax\n" puts
    elif dup @Op.type OP_MINUS = do
       "    ;; -- minus --\n" puts
       "    pop rax\n" puts
       "    pop rbx\n" puts
       "    sub rbx, rax\n" puts
       "    push rbx\n" puts
    elif dup @Op.type OP_PRINT = do
       "    ;; -- print --\n" puts
       "    pop rdi\n" puts
       "    call print\n" puts
    elif dup @Op.type OP_DUP = do
       "    ;; -- dup --\n" puts
       "    pop rax\n" puts
       "    push rax\n" puts
       "    push rax\n" puts
    elif dup @Op.type OP_DROP = do
       "    ;; -- drop --\n" puts
       "    pop rax\n" puts
    else
       here eputs ": unreachable\n" eputs 1 exit
    end

    drop

    1 +
  end
  drop

  "    mov rax, 60\n" puts
  "    mov rdi, 0\n" puts
  "    syscall\n" puts
  "segment .bss\n" puts
  "args_ptr: resq 1\n" puts
  "mem: resb " puts MEM_CAPACITY putd "\n" puts
end  

macro simulate-ops // --
  0 while dup ops-count @64 < do
    dup sizeof(Op) * ops +

    if COUNT_OPS 6 != do
      here eputs ": Assertion Failed: Exhaustive handling of Op types in simulate-ops\n" eputs
      1 exit
    end

    if dup @Op.type OP_PUSH_INT = do
       dup @Op.operand sim-stack-push
    elif dup @Op.type OP_PLUS = do
       sim-stack-pop
       sim-stack-pop
       +
       sim-stack-push
    elif dup @Op.type OP_MINUS = do
       sim-stack-pop
       sim-stack-pop
       swap
       -
       sim-stack-push
    elif dup @Op.type OP_PRINT = do
       sim-stack-pop print
    elif dup @Op.type OP_DUP = do
       sim-stack-pop
       dup
       sim-stack-push
       sim-stack-push
    elif dup @Op.type OP_DROP = do
       sim-stack-pop
       drop
    else
       here eputs ": unreachable\n" eputs 1 exit
    end

    drop

    1 +
  end
  drop
end

macro parse_file_path_cstr_into_ops
  O_RDONLY                     // flags
  file_path_cstr @64 cast(ptr) // pathname
  AT_FDCWD                     // dirfd
  openat

  if dup 0 < do
    "ERROR: could not open file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  fd !64

  if statbuf fd @64 fstat 0 < do
    "ERROR: could not determine the size of file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  statbuf @stat.st_size content !Str.count

  0                        // offset
  fd @64                   // fd
  MAP_PRIVATE              // flags
  PROT_READ                // prot
  content @Str.count       // length
  NULL                     // addr
  mmap
  content !Str.data

  if content @Str.data cast(int) 0 < do
    "ERROR: could not memory map file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  1 line_number !64
  while content @Str.count 0 > do
    line content str-chop-line
    line @Str.data line_start !64
    while line @Str.count 0 > do
       line str-trim-left
       word line str-chop-word

       if COUNT_OPS 6 != do
         here eputs ": Assertion Failed: Exhaustive handling of Op types in parse-file-path\n" eputs
         1 exit
       end

       if word @Str "+" streq do
         OP_PLUS 0 push-op
       elif word @Str "-" streq do
         OP_MINUS 0 push-op
       elif word @Str "print" streq do
         OP_PRINT 0 push-op
       elif word @Str "dup" streq do
         OP_DUP 0 push-op
       elif word @Str "drop" streq do
         OP_DROP 0 push-op
       else
         OP_PUSH_INT try_to_parse_word_as_int_or_fail_as_unknown_word push-op
       end
    end
    line_number inc64
  end
  // TODO: parse_file_path does not clean up resources after itself
end

macro usage // --
  dup "Usage: porth <SUBCOMMAND>\n" rot fputs
  dup "  SUBCOMMANDS:\n" rot fputs
  dup "    sim <file>       Simulate the program.\n" rot fputs
  dup "    com <file>       Compile the program\n" rot fputs
  dup "    dump <file>      Dump the ops of the program\n" rot fputs
  dup "    help             Print this help to stdout and exit with 0 code\n" rot fputs
  drop
end

macro main // --
  if argc 2 < do
    stderr usage
    "ERROR: subcommand is not provided\n" eputs
    1 exit
  end

  1 nth_argv
  if dup "sim"c cstreq do
    if argc 3 < do
      stderr usage
      "ERROR: no input file is provided for the `sim` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    simulate-ops
  elif dup "com"c cstreq do
    if argc 3 < do
      stderr usage
      "ERROR: no input file is provided for the `com` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    compile-ops
  elif dup "help"c cstreq do
    stdout usage
    0 exit
  elif dup "dump"c cstreq do
    if argc 3 < do
      stderr usage
      "ERROR: no input file is provided for the `dump` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    dump-ops
  else
    stderr usage
    "ERROR: unknown subcommand `" eputs dup cstr-to-pstr eputs "`\n" eputs
    1 exit
  end
  drop
end

main
