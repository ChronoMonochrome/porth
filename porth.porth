// In progress rewrite of ./porth.py in Porth

include "std.porth"

macro MEM_CAPACITY 640000 end
macro SIM_STACK_CAP 1024 end

macro OP_PUSH_INT  0 end
macro OP_INTRINSIC 1 end
macro COUNT_OPS    2 end

macro INTRINSIC_PLUS     0 end
macro INTRINSIC_MINUS    1 end
macro INTRINSIC_MUL      2 end
macro INTRINSIC_PRINT    3 end
macro INTRINSIC_DUP      4 end
macro INTRINSIC_DROP     5 end
macro COUNT_INTRINSICS   6 end

macro OPS_CAP       1024 end
macro sizeof(Op)    16 end
macro Op.type       0 + end
macro Op.operand    8 + end
macro @Op.type      Op.type @64 end
macro !Op.type      Op.type !64 end
macro @Op.operand   Op.operand @64 end
macro !Op.operand   Op.operand !64 end

memory file_path_cstr  sizeof(ptr)                 end
memory fd              sizeof(u64)                 end
memory statbuf         sizeof(stat)                end
memory content         sizeof(Str)                 end
memory line            sizeof(Str)                 end
memory word            sizeof(Str)                 end
memory line_number     sizeof(u64)                 end
memory line_start      sizeof(ptr)                 end
memory sim-stack-count sizeof(u64)                 end
memory sim-stack       sizeof(u64) SIM_STACK_CAP * end
memory ops-count       sizeof(u64)                 end
memory ops             sizeof(Op) OPS_CAP *        end

memory out_fd sizeof(u64) end
macro @out_fd out_fd @64 end
macro !out_fd out_fd !64 end

memory empty_envp sizeof(ptr) end
memory nasm_argv sizeof(ptr) 4 * end
// TODO: search for external utilities in $PATH
"/usr/bin/nasm"c nasm_argv 0 8 * + !64
"-felf64"c       nasm_argv 1 8 * + !64
"output.asm"c    nasm_argv 2 8 * + !64

memory ld_argv sizeof(ptr) 5 * end
"/usr/bin/ld"c ld_argv 0 8 * + !64
"-o"c          ld_argv 1 8 * + !64
"output"c      ld_argv 2 8 * + !64
"output.o"c    ld_argv 3 8 * + !64

memory output_argv sizeof(ptr) 2 * end
"./output"c output_argv 0 8 * + !64

memory wstatus sizeof(u64) end
proc cmd_echoed // argv
  "[CMD]" puts
  dup while dup @64 0 != do
    " " puts
    // TODO: properly escape the logged CMD
    dup @64 cast(ptr) cstr-to-str puts
    8 +
  end drop
  "\n" puts

  fork
  
  dup 0 = if
    drop
    dup @64 cast(ptr) empty_envp
    rot rot
    execve
    dup 0 < if
      "[ERROR] could not exec external program\n" eputs
      1 exit
    end
  orelse dup 0 > if
    drop
    // TODO: handle the result of wait4
    NULL 0 wstatus -1 wait4 drop
  else
    drop
    "[ERROR] could not fork a child\n" eputs
    1 exit
  end
  
  drop
end

proc sim-stack-push // u64 --
  sim-stack-count @64 SIM_STACK_CAP >= if
    here eputs ": ERROR: data stack overflow in simulation mode\n" eputs 1 exit
  end
  sim-stack sim-stack-count @64 8 * + !64
  sim-stack-count inc64
end

proc sim-stack-pop // -- u64
  sim-stack-count @64 0 = if
    here eputs ": ERROR: data stack underflow in simulation mode\n" eputs 1 exit
  end
  sim-stack-count dec64
  sim-stack sim-stack-count @64 8 * + @64
end

proc try_to_parse_word_as_int_or_fail_as_unknown_word // n1 s1 - ret
  0 0 while dup word @Str.count < do
    dup word @Str.data + @8

    dup isdigit lnot if
      file_path_cstr @64 cast(ptr) cstr-to-str eputs
      ":" puts line_number @64 putd
      ":" puts word @Str.data cast(int) line_start @64 - 1 + putd
      ": ERROR: `" eputs word @Str eputs "` is unknown word\n" eputs
      1 exit
    end

    '0' -
    rot 10 * +
    swap
    1 +
  end drop
end


proc push-op // type operand -- 
  // TODO: assert OPS_CAP
  ops-count @64 sizeof(Op) * ops +
  dup rot swap !Op.operand
  !Op.type
  ops-count inc64
end

proc print-op-type
  COUNT_OPS 2 != if
    here eputs ": Assertion Failed: Exhaustive handling of Op types in print-op-type\n" eputs
    1 exit
  end

  dup OP_PUSH_INT = if
    "OP_PUSH_INT" puts
  orelse dup OP_INTRINSIC = if
    "OP_INTRINSIC" puts
  else
    here eputs ": Unknown op type\n" eputs 1 exit
  end
  drop
end

proc dump-ops // --
  0 while dup ops-count @64 < do
    // ptr ptr
    dup sizeof(Op) * ops +
    "Type:    " puts dup @Op.type print-op-type "\n" puts
    "Operand: " puts @Op.operand putd           "\n" puts
    "----------\n" puts
    1 +
  end
  drop
end

proc compile-ops // --
  "[INFO] Generating output.asm\n" puts

  420                  // mode
  O_CREAT O_WRONLY or  // flags
  // TODO: the output file path should be based on the input file path
  "output.asm"c        // pathname
  AT_FDCWD
  openat
  !out_fd

  @out_fd 0 < if
    "[ERROR] could not open `output.asm`\n" eputs
    1 exit
  end

  "BITS 64\n"                              @out_fd fputs
  "segment .text\n"                        @out_fd fputs
  "print:\n"                               @out_fd fputs
  "    mov     r9, -3689348814741910323\n" @out_fd fputs
  "    sub     rsp, 40\n"                  @out_fd fputs
  "    mov     BYTE [rsp+31], 10\n"        @out_fd fputs
  "    lea     rcx, [rsp+30]\n"            @out_fd fputs
  ".L2:\n"                                 @out_fd fputs
  "    mov     rax, rdi\n"                 @out_fd fputs
  "    lea     r8, [rsp+32]\n"             @out_fd fputs
  "    mul     r9\n"                       @out_fd fputs
  "    mov     rax, rdi\n"                 @out_fd fputs
  "    sub     r8, rcx\n"                  @out_fd fputs
  "    shr     rdx, 3\n"                   @out_fd fputs
  "    lea     rsi, [rdx+rdx*4]\n"         @out_fd fputs
  "    add     rsi, rsi\n"                 @out_fd fputs
  "    sub     rax, rsi\n"                 @out_fd fputs
  "    add     eax, 48\n"                  @out_fd fputs
  "    mov     BYTE [rcx], al\n"           @out_fd fputs
  "    mov     rax, rdi\n"                 @out_fd fputs
  "    mov     rdi, rdx\n"                 @out_fd fputs
  "    mov     rdx, rcx\n"                 @out_fd fputs
  "    sub     rcx, 1\n"                   @out_fd fputs
  "    cmp     rax, 9\n"                   @out_fd fputs
  "    ja      .L2\n"                      @out_fd fputs
  "    lea     rax, [rsp+32]\n"            @out_fd fputs
  "    mov     edi, 1\n"                   @out_fd fputs
  "    sub     rdx, rax\n"                 @out_fd fputs
  "    xor     eax, eax\n"                 @out_fd fputs
  "    lea     rsi, [rsp+32+rdx]\n"        @out_fd fputs
  "    mov     rdx, r8\n"                  @out_fd fputs
  "    mov     rax, 1\n"                   @out_fd fputs
  "    syscall\n"                          @out_fd fputs
  "    add     rsp, 40\n"                  @out_fd fputs
  "    ret\n"                              @out_fd fputs
  "global _start\n"                        @out_fd fputs
  "_start:\n"                              @out_fd fputs
  "    mov [args_ptr], rsp\n"              @out_fd fputs

  0 while dup ops-count @64 < do
    dup sizeof(Op) * ops +

    // TODO: compile time assertion
    COUNT_OPS 2 != if
      here eputs ": Assertion Failed: Exhaustive handling of Op types in compile-ops\n" eputs
      1 exit
    end

    dup @Op.type OP_PUSH_INT = if
       "    ;; -- push int "  @out_fd fputs dup @Op.operand @out_fd fputd " --\n" @out_fd fputs
       "    mov rax, "        @out_fd fputs dup @Op.operand @out_fd fputd "\n"    @out_fd fputs
       "    push rax\n"       @out_fd fputs
    orelse dup @Op.type OP_INTRINSIC = if
        COUNT_INTRINSICS 6 != if
          here eputs ": Assertion Failed: Exhaustive handling of Intrinsics in compile-ops\n" eputs
          1 exit
        end

        dup @Op.operand INTRINSIC_PLUS = if
           "    ;; -- plus --\n"  @out_fd fputs
           "    pop rax\n"        @out_fd fputs
           "    pop rbx\n"        @out_fd fputs
           "    add rax, rbx\n"   @out_fd fputs
           "    push rax\n"       @out_fd fputs
        orelse dup @Op.operand INTRINSIC_MINUS = if
           "    ;; -- minus --\n" @out_fd fputs
           "    pop rax\n"        @out_fd fputs
           "    pop rbx\n"        @out_fd fputs
           "    sub rbx, rax\n"   @out_fd fputs
           "    push rbx\n"       @out_fd fputs
        orelse dup @Op.operand INTRINSIC_MUL = if
           "    ;; -- mul --\n"   @out_fd fputs
           "    pop rax\n"        @out_fd fputs
           "    pop rbx\n"        @out_fd fputs
           "    mul rbx\n"        @out_fd fputs
           "    push rax\n"       @out_fd fputs
        orelse dup @Op.operand INTRINSIC_PRINT = if
           "    ;; -- print --\n" @out_fd fputs
           "    pop rdi\n"        @out_fd fputs
           "    call print\n"     @out_fd fputs
        orelse dup @Op.operand INTRINSIC_DUP = if
           "    ;; -- dup --\n"   @out_fd fputs
           "    pop rax\n"        @out_fd fputs
           "    push rax\n"       @out_fd fputs
           "    push rax\n"       @out_fd fputs
        orelse dup @Op.operand INTRINSIC_DROP = if
           "    ;; -- drop --\n"  @out_fd fputs
           "    pop rax\n"        @out_fd fputs
        else
           here eputs ": unreachable.\n" eputs
           1 exit
        end
    else
       here eputs ": unreachable.\n" eputs
       1 exit
    end

    drop

    1 +
  end
  drop

  "    mov rax, 60\n"  @out_fd fputs
  "    mov rdi, 0\n"   @out_fd fputs
  "    syscall\n"      @out_fd fputs
  "segment .bss\n"     @out_fd fputs
  "args_ptr: resq 1\n" @out_fd fputs
  "mem: resb "         @out_fd fputs MEM_CAPACITY @out_fd fputd "\n" @out_fd fputs

  @out_fd close drop

  nasm_argv cmd_echoed
  ld_argv cmd_echoed
  output_argv cmd_echoed
end  

proc simulate-ops // --
  0 while dup ops-count @64 < do
    dup sizeof(Op) * ops +

    COUNT_OPS 7 != if
      here eputs ": Assertion Failed: Exhaustive handling of Op types in simulate-ops\n" eputs
      1 exit
    end

    dup @Op.type OP_PUSH_INT = if
       dup @Op.operand sim-stack-push
    orelse dup @Op.type OP_INTRINSIC = if
        dup @Op.operand INTRINSIC_PLUS = if
           sim-stack-pop
           sim-stack-pop
           +
           sim-stack-push
        orelse dup @Op.operand INTRINSIC_MINUS = if
           sim-stack-pop
           sim-stack-pop
           swap
           -
           sim-stack-push
        orelse dup @Op.operand INTRINSIC_MUL = if
           sim-stack-pop
           sim-stack-pop
           *
           sim-stack-push
        orelse dup @Op.operand INTRINSIC_PRINT = if
           sim-stack-pop print
        orelse dup @Op.operand INTRINSIC_DUP = if
           sim-stack-pop
           dup
           sim-stack-push
           sim-stack-push
        orelse dup @Op.operand INTRINSIC_DROP = if
           sim-stack-pop
           drop
        else
           here eputs ": unreachable\n" eputs 1 exit
        end
    else
       here eputs ": unreachable\n" eputs 1 exit
    end

    drop

    1 +
  end
  drop
end

proc parse_file_path_cstr_into_ops
  0                            // mode
  O_RDONLY                     // flags
  file_path_cstr @64 cast(ptr) // pathname
  AT_FDCWD                     // dirfd
  openat

  dup 0 < if
    "ERROR: could not open file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  fd !64

  statbuf fd @64 fstat 0 < if
    "ERROR: could not determine the size of file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  statbuf @stat.st_size content !Str.count

  0                        // offset
  fd @64                   // fd
  MAP_PRIVATE              // flags
  PROT_READ                // prot
  content @Str.count       // length
  NULL                     // addr
  mmap
  content !Str.data

  content @Str.data cast(int) 0 < if
    "ERROR: could not memory map file " eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "\n" eputs
    1 exit
  end

  1 line_number !64
  while content @Str.count 0 > do
    '\n' line content str-chop-by-delim
    line @Str.data line_start !64
    while line @Str.count 0 > do
       line str-trim-left
       ' ' word line str-chop-by-delim

       COUNT_OPS 2 != if
         here eputs ": Assertion Failed: Exhaustive handling of Op types in parse-file-path\n" eputs
         1 exit
       end

       COUNT_INTRINSICS 6 != if
         here eputs ": Assertion Failed: Exhaustive handling of Intrinsics in parse-file-path\n" eputs
         1 exit
       end

       word @Str "+" streq if
         OP_INTRINSIC INTRINSIC_PLUS push-op
       orelse word @Str "-" streq if
         OP_INTRINSIC INTRINSIC_MINUS push-op
       orelse word @Str "*" streq if
         OP_INTRINSIC INTRINSIC_MUL push-op
       orelse word @Str "print" streq if
         OP_INTRINSIC INTRINSIC_PRINT push-op
       orelse word @Str "dup" streq if
         OP_INTRINSIC INTRINSIC_DUP push-op
       orelse word @Str "drop" streq if
         OP_INTRINSIC INTRINSIC_DROP push-op
       else
         OP_PUSH_INT try_to_parse_word_as_int_or_fail_as_unknown_word push-op
       end
    end
    line_number inc64
  end
  // TODO: parse_file_path does not clean up resources after itself
end

proc usage // --
  dup "Usage: porth <SUBCOMMAND>\n" rot fputs
  dup "  SUBCOMMANDS:\n" rot fputs
  dup "    sim <file>       Simulate the program.\n" rot fputs
  // TODO: -r flag for com subcommand
  dup "    com <file>       Compile the program\n" rot fputs
  dup "    dump <file>      Dump the ops of the program\n" rot fputs
  dup "    help             Print this help to stdout and exit with 0 code\n" rot fputs
  drop
end

proc main // --
  argc 2 < if
    stderr usage
    "ERROR: subcommand is not provided\n" eputs
    1 exit
  end

  1 nth_argv
  dup "sim"c cstreq if
    argc 3 < if
      stderr usage
      "ERROR: no input file is provided for the `sim` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    simulate-ops
  orelse dup "com"c cstreq if
    argc 3 < if
      stderr usage
      "ERROR: no input file is provided for the `com` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    compile-ops
  orelse dup "help"c cstreq if
    stdout usage
    0 exit
  orelse dup "dump"c cstreq if
    argc 3 < if
      stderr usage
      "ERROR: no input file is provided for the `dump` subcommand\n" eputs
      1 exit
    end

    2 nth_argv file_path_cstr !64

    parse_file_path_cstr_into_ops

    dump-ops
  else
    stderr usage
    "ERROR: unknown subcommand `" eputs dup cstr-to-pstr eputs "`\n" eputs
    1 exit
  end
  drop
end

main
